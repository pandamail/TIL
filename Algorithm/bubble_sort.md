제목: [알고리즘] 버블 정렬 (Bubble Sort) - 'AI 튜터'로 논리부터 이해하기

1. 문제:

    리스트 [5, 1, 4, 2]를 오름차순으로 정렬하시오.

2. 내가 이해한 핵심 논리 (러버덕 설명):

    핵심 규칙: "바로 옆 짝꿍끼리만 비교한다."

    1회전 (Pass 1): [5, 1, 4, 2] → [1, 5, 4, 2] → [1, 4, 5, 2] → [1, 4, 2, 5]

    (깨달음: 가장 큰 수 5가 거품처럼 맨 뒤로 밀려났다.)

    2회전 (Pass 2): [1, 4, 2, 5] → [1, 4, 2, 5](유지) → [1, 2, 4, 5](스왑) → [1, 2, 4, 5](유지)

    (깨달음: 두 번째 큰 수 4가 제자리를 찾았다.)

    3회전 (Pass 3): [1, 2, 4, 5] → (비교) → (비교) → (비교)

    (깨달음: '스왑(Swap)이 0번' 일어났다. 즉, 정렬이 끝났다는 '신호'다!)

3. 코드로 번역 (왜 이중 for문인가?):

    바깥쪽 for문 (i): '회전(Pass)'을 반복하는 역할.

    안쪽 for문 (j): 각 회전마다 '짝꿍 비교(Swap)'를 실행하는 역할.

    if swap_count == 0: break: 3회전처럼 스왑이 0번이면, 이미 정렬됐으니 멈추라는 '효율화' 코드.


**python code**
def bubble_sort(arr):
    n = len(arr) # 배열의 길이

    # 1. 'Pass'를 반복하는 바깥쪽 for문 (최대 n-1번)
    for i in range(n - 1):
        swap_count = 0 # 이번 Pass의 스왑 횟수

        # 2. '짝꿍 비교'를 반복하는 안쪽 for문
        # (i가 늘어날수록 비교 범위(n-1-i)가 줄어듦)
        for j in range(n - 1 - i):
            if arr[j] > arr[j+1]: # 왼쪽이 더 크면
                arr[j], arr[j+1] = arr[j+1], arr[j] # 스왑!
                swap_count += 1

        # 3. '종료 조건' 검사
        if swap_count == 0:
            break # 이번 Pass에 스왑이 없었으면, 정렬 완료!

    return arr

print(bubble_sort([5, 1, 4, 2]))
# 출력: [1, 2, 4, 5]

