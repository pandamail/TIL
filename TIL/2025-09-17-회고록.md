# 2025-09-17:

## **2025-09-17: 동적 환경변수 주입과 CI/CD 환경 구축**

### 🤔 **문제 상황 (Problem)**
전날 구축한 Docker 자동화 시스템에서, 각 학교별로 생성된 프론트엔드(Admin, User)가 자신에게 맞는 백엔드를 찾아가지 못하고 API 연결에 실패하는 문제가 지속적으로 발생했다. 특히, `admin`과 `user` 프로젝트는 서로 다른 환경 변수 관리 방식(`env.js` vs `.env.production`)을 사용하고 있어 문제 해결을 더욱 복잡하게 만들었다.

### 💡 **해결 과정 (Solution)**

#### **1. 근본 원인 분석: 정적 빌드의 한계**
문제의 핵심은 프론트엔드 빌드 시점에 API 주소가 **하드코딩(Hard-coding)**되어, 여러 개의 독립된 백엔드 환경을 동적으로 바라볼 수 없는 구조라는 점을 파악했다. `yarn build` 시점에 환경 변수가 코드에 박제되기 때문에, 런타임에 다른 백엔드를 지정해 줄 방법이 없었다.

#### **2. 해결책: 동적 `env.js` 주입 아키텍처 설계**
이 문제를 해결하기 위해, 두 프론트엔드의 환경 변수 관리 방식을 **'동적 `env.js` 주입'** 방식으로 통일했다.
- **`main.py` 수정:** Flask API 서버가 컨테이너를 생성할 때, 해당 환경의 정확한 백엔드 주소가 담긴 `env.js` 파일을 **동적으로 생성**하도록 로직을 업그레이드했다.
- **프론트엔드 소스 코드 수정:**
    - `index.html`에 `<script src="/env.js"></script>`를 추가하여, 앱이 실행될 때 동적으로 생성된 환경 변수 파일을 가장 먼저 읽도록 했다.
    - `axios` 설정(`instance.ts`)이 `VITE_SERVER_URL` 대신 `window.env.BE_HOST`를 바라보도록 수정하여, `main.py`가 주입해 준 주소를 사용하도록 통일했다.

#### **3. 빌드 환경 문제 해결**
`user` 프로젝트에서 `yarn build`가 계속 실패하는 고질적인 문제가 있었다. 이는 Node.js 버전 비호환성 문제로 판단, **프로젝트를 재클론**하고 최소한의 코드( `index.html`, `instance.ts`)만 수정한 뒤 `yarn install`과 `yarn build`를 다시 실행하여 빌드 환경을 정상화하고 문제를 해결했다.

### 📖 **배운 점 (What I Learned)**
- **빌드 시점(Build-time)과 실행 시점(Run-time)의 차이:** `.env` 파일은 빌드 시점에 값이 결정되는 반면, `env.js` 스크립트 주입은 실행 시점에 동적으로 값을 결정할 수 있어, 이번 프로젝트처럼 동적인 다중 환경을 구성하는 데 매우 효과적이라는 것을 배웠다.
- **체계적인 리팩토링:** 두 개의 다른 시스템(`admin`, `user`)이 있을 때, 성공적으로 작동하는 한쪽(`admin`)의 방식을 기준으로 다른 쪽을 통일시키는 것이 문제 해결의 확실한 방법임을 체득했다.
- **끈질긴 디버깅의 가치:** 수차례의 재클론과 빌드 실패를 겪었지만, 포기하지 않고 원인을 추적하여 해결했을 때의 성취감과 그 과정에서 얻는 깊은 지식의 중요성을 깨달았다.

---
### **추가 성과: Jenkins CI/CD 환경 구축**
- `apt` 설치 방식의 복잡성을 피해, **Docker를 이용해 Jenkins를 안정적으로 설치**하고 포트 충돌 문제를 해결했다.
- Jenkins에 GitLab 플러그인을 설치하고, 모든 CBT 프로젝트(`admin`, `user`, `db`, `백엔드`)의 소스 코드를 **Git 레포지토리에서 자동으로 클론**하는 Freestyle Job 설정을 완료하며 CI(지속적 통합)의 첫 단계를 성공적으로 구현했다.

## 📖 오늘 배운 점 (What I Learned)

    오늘도 출근을 해서 어제 마무리짓지 못했던 Docker 환경을 마무리 짓는다고 애를 썻다.
    처음에는 프론트엔드 화면(admin, user)이 생성은 됐지만 백엔드를 연결하지 못하는 오류가 계속 떳다.

    아무리 생각해도 .env.js 와 .env.production이 문제인데 어떻게 해결해야할지 갈피가 잡히지 않았다.
    그러다가 생각이 든 것은 admin과 user를 빌드하는 과정에서 하드코딩 되어있으면 어떻게든 이상한 값을 가르킨다는 것이었다.

    이를 깨닫고 난 후에 CBT 환경 생성기의 main.py에서 .env.js의 역할을 하는 동적인 움직임을 보일 수 있는 방법을 모색하게 되었고. 그 결과 admin은 각 포트별로 백엔드에 연동하는데 성공했다.

    그러나 user는 되지가 않았고 왜 안되는가를 계속 궁금해 한 결과 user의 소스코드 중 user/src/api/instance.ts 파일이 .env.production에 있는 VITE TEST 코드의 백엔드 주소에서 불러오는 것을 알게 되었고

    const instance = axios.create({
    baseURL: (window as any).env?.BE_HOST,
    withCredentials: false
    });

    함수를 main.py에서 생성하는 env.js로 전환시키니 이제 실마리가 풀리는가 했다.

    그치만 여기서 또 문제가 되는게 있었으니...

    분명 선임분들이 이미 완성시켜놓은 프로젝트를 클론해서 하는 것이다 보니 내가 하는 프로젝트에는 실패를 한다면 그것은 다 내가 그들이 걸어온 방식으로 한 것이 아니기 때문에. 나는 안 되면 내가 잘못한걸 알고있다...

    다름아니라 yarn build를 할때마다 build가 되지 않는것이었다..
    오류를 찾으려고 애썻지만 결국 찾지 못했고 나는 삭제 후 다시 clone을 하게 된다.

    그 과정을 3번정도 겪으니 딱 바꿔야되는 파일 (index.html, instace.ts)을 바꾸고 바로 yarn install -> yarn build 후에 cp 하고나니

    약 5시간동안 나의 골머리를 싸매었던 cbt user 창이 백엔드에 연결이 된 것이다..
    너무 기뻣다.

    그리고 젠킨스를 설치하게 되었다. jenkins도 apt install로 곱게 설치가 되지 않았다.
    이녀석도 jenkins war, docker를 사용한 설치방법 총 3번의 시도끝에 설치를 완료할 수 있었고

    caddy 친구와 포트싸움을 하는 바람에 또 나의 시간을 뺏어버렸다. 포트는 정말 자리싸움이다.
    우여곡절이 있었지만 오늘의 목표인 jenkins 연결 및 프로젝트 clone까지 도달하는데 성공했다.

    좋은 하루였다.