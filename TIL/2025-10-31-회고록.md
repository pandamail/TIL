# 📅 2025년 10월 31일 - 일일 학습 기록

## 🚀 오늘 한 일
- [x] `user-exam.spec.ts`의 실패 테스트 디버깅 및 안정화 작업
  - '오답 표시' 기능의 숨은 로케이터 버그 수정
  - '메모 기능' 테스트의 다각적 분석 및 'Stale Element' 근본 원인 규명

## 📚 새로 배운 것
### Playwright의 Stale Element 참조 오류
- **설명**: 페이지 이동이나 DOM 구조 변경으로 인해 이전에 찾아뒀던 웹 요소(Element)가 사라지거나 유효하지 않게 되는 현상. 이 '오래된(Stale)' 요소를 다시 참조하려고 할 때 발생하는 오류다.
- **해결**: 오래된 참조를 재사용하는 대신, DOM 변경이 일어난 후에는 `page.locator(...)` 등으로 요소를 **새롭게 다시 찾아야** 한다.

### CSS 상속과 로케이터 전략
- **설명**: 때로는 특정 스타일(`line-through` 등)이 눈에 보이는 텍스트(`<span>`)가 아닌, 그 부모나 조상 요소(`<li>` 등)에 직접 적용될 수 있다.
- **교훈**: 로케이터가 특정 요소의 스타일을 제대로 잡지 못할 때는, 개발자 도구를 통해 스타일이 실제로 어느 요소에 적용되었는지 확인하고 로케이터의 대상을 상위 요소로 변경하는 전략이 유효하다.

## 💻 코드 스니펫
```typescript
// '오답 표시' 기능에서 취소선 스타일이 적용된 요소를 찾는 로케이터 수정

// 실패했던 코드: <span> 태그에서 스타일을 찾으려 함
// const incorrectMark = page.locator('div.text-base > span');
// await expect(incorrectMark).toHaveCSS('text-decoration', /line-through/);

// 성공한 코드: 실제 스타일이 적용된 <li> 태그를 대상으로 지정
const answerItem = page.locator('li.flex.items-center.gap-2').filter({ hasText: '정답 보기 1' });
await expect(answerItem).toHaveCSS('text-decoration', /line-through/);
```

## 🤔 고민한 부분
- '메모 기능' 테스트를 수정하는 과정에서 전혀 다른 '오답 표시' 테스트가 실패하는 사이드 이펙트를 경험했다. 하나의 수정이 다른 곳에 미치는 영향을 항상 생각해야 하며, 관련 없어 보이는 테스트도 함께 실행해보는 것이 중요하다고 느꼈다.
- '다음 문제(2번)'로 이동하는 로케이터가 '보기 2번'을 클릭할 수 있는 모호한 로케이터였다. `getByRole('button', { name: '2' })`처럼 이름만으로 요소를 찾을 경우, 의도치 않은 동작을 유발할 수 있음을 깨달았다. 컨테이너로 범위를 좁히는 등 더 명확한 로케이터 전략이 필수적이다.
- 결국 '메모 기능' 테스트를 오늘 완전히 해결하지 못해 아쉽다. 하지만 근본 원인인 'Stale Element' 문제까지 도달했으니, 해결의 실마리는 잡았다고 생각한다.

## 📌 내일 할 일
- [ ] '메모 기능' 테스트의 'Stale Element' 문제를 해결하기 (요소 재검색 로직 적용)
- [ ] `user-exam.spec.ts`의 남은 세부 기능(필터링 등) 테스트 구현 마무리

---
**한 줄 회고**: 버그의 표면이 아닌 근본 원인을 파고드는 과정에서 한 단계 더 성장했다. 아쉬움은 내일의 동력으로!

**태그**: #Playwright #E2E테스트 #디버깅 #StaleElement
