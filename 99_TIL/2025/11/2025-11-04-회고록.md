# 📅 2025년 11월 4일 - 일일 학습 기록

## 🚀 오늘 한 일
- [x] `user-exam.spec.ts`의 '체크 문제' 필터링 테스트 로직을 수정하고 디버깅함.
- [ ] Strict Mode 위반, 클릭 방해, 로케이터 모호성 등 복합적인 문제를 해결하기 위해 로케이터를 수정하는 작업을 진행함. (진행 중)

## 📚 새로 배운 것
### Playwright 로케이터 심화
- **`.filter({ hasNot: ... })`**: 특정 하위 요소를 포함하지 않는 요소를 필터링하여, 더 정밀한 로케이터를 만들 수 있다. 예를 들어, 특정 컨테이너 외부의 버튼을 타겟팅할 때 유용하다.
- **`li:has(svg)`**: CSS 선택자 `:has()`를 사용하여 특정 자식(예: `svg` 아이콘)을 가진 부모 `<li>` 요소를 찾을 수 있다. 이는 상태 변화에 따라 DOM 구조가 동적으로 바뀔 때 안정적인 검증 포인트를 제공한다.

## 💻 코드 스니펫
```typescript
// '체크 문제' 필터 버튼을 찾기 위한 복잡한 로케이터 수정 과정
// 1. 초기 시도 (모호함)
// userPage.getByTitle('체크 문제');

// 2. 최종 수정 (특정 컨테이너를 제외하고, 텍스트 패턴을 가짐)
const filterButton = userPage.getByTitle('체크 문제').filter({ hasNot: userPage.locator('div.question-container'), hasText: '(' });

// 필터링된 결과(체크된 문제)의 개수를 세는 로케이터
const checkedItems = answerSheet.locator('li:has(svg)');
```

## 🤔 고민한 부분
- Playwright의 `Strict Mode`는 하나의 로케이터가 여러 요소를 가리킬 때 오류를 발생시킨다. 이는 의도치 않은 요소를 클릭하는 것을 방지해주지만, 때로는 매우 구체적인 로케이터 작성을 요구하여 디버깅 시간을 늘리기도 한다. `.first()`, `.last()`, `.filter()` 등을 적절히 활용하여 로케이터의 모호성을 해결하는 능력이 중요하다고 느꼈다.
- 테스트 흐름을 단순화하는 것이 디버깅에 큰 도움이 되었다. 여러 문제를 체크하고 검증하는 대신, 단 1개의 문제만 체크하고 필터링 결과를 확인하는 방식으로 변경하니 문제의 원인을 더 명확하게 파악할 수 있었다.

## 📌 내일 할 일
- [ ] '체크 문제' 필터링 테스트의 남은 문제 해결
- [ ] '미응답 문제' 필터링 테스트 최종 검증 및 완료

---
**한 줄 회고**: 복잡한 UI 상호작용 테스트는 로케이터와의 싸움이다. 더 안정적이고 명확한 로케이터를 작성하는 연습을 꾸준히 해야겠다.

**태그**: #Playwright #E2E테스트 #디버깅 #Locator #StrictMode
